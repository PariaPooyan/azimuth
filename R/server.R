#' @include zzz.R
#'
NULL

#' Server function for the mapping app
#'
#' @param input,output,session Required Shiny app server parameters
#'
#' @return The shiny server logic
#'
#' @importFrom DT dataTableProxy renderDT selectRows
#' @importFrom future future plan resolved value
#' @importFrom ggplot2 annotate geom_hline ggtitle scale_colour_hue
#' theme_void xlab layer_scales xlim ylim ylab ggtitle theme element_text
#' @importFrom googlesheets4 gs4_auth gs4_get sheet_append
#' @importFrom methods slot slot<- new
#' @importFrom presto wilcoxauc
#' @importFrom SeuratObject AddMetaData Assays Cells DefaultAssay Embeddings
#' GetAssayData Idents Idents<- Key RenameCells Reductions Tool SetAssayData
#' VariableFeatures
#' @importFrom Seurat DimPlot FeaturePlot FindNeighbors FindTransferAnchors
#' IntegrateEmbeddings MappingScore NoLegend PercentageFeatureSet
#' RunUMAP TransferData SCTransform VlnPlot
#' @importFrom shiny downloadHandler observeEvent isolate Progress
#' reactiveValues renderPlot renderTable renderText removeUI setProgress
#' safeError updateNumericInput updateSelectizeInput withProgress renderUI
#' onStop
#' @importFrom shinydashboard menuItem renderMenu renderValueBox
#' sidebarMenu valueBox
#' @importFrom shinyjs addClass enable disable hide removeClass show
#' @importFrom stringr str_interp
#' @importFrom patchwork wrap_plots plot_layout
#' @importFrom stats na.omit quantile
#' @importFrom utils write.table packageVersion
#'
#' @keywords internal
#'
AzimuthServer <- function(input, output, session) {
  # hide demo dataset button if required
  if (is.null(x = getOption(x = 'Azimuth.app.demodataset'))) {
    hide(id="triggerdemo")
  }
  mt.key <- 'percent.mt'
  mito.pattern <- getOption(x = 'Azimuth.app.mito', default = '^MT-')
  do.adt <- isTRUE(x = getOption(x = 'Azimuth.app.do_adt', default = TRUE))
  adt.key <- 'impADT'
  n.trees <- getOption(x = "Azimuth.map.ntrees")
  app.env <- reactiveValues(
    adt.features = character(length = 0L),
    anchors = NULL,
    demo = FALSE,
    default.assay = NULL,
    default.feature = NULL,
    default.metadata = NULL,
    diff.exp = list(),
    feature = '',
    features = character(length = 0L),
    mapping.score = NULL,
    messages = 'Upload a file',
    ncellsupload = 0L,
    ncellspreproc = 0L,
    object = NULL,
    metadata.cont = character(length = 0L),
    scorefeatures = character(length = 0L),
    plot.ranges = list(),
    query.qc = NULL
  )
  react.env <- reactiveValues(
    no = FALSE,
    anchors = FALSE,
    biomarkers = FALSE,
    features = FALSE,
    map = FALSE,
    markers = FALSE,
    metadata = FALSE,
    mt = FALSE,
    xferopts = FALSE,
    path = NULL,
    pbcor = FALSE,
    progress = NULL,
    qc = FALSE,
    score = FALSE,
    sctransform = FALSE,
    start = numeric(length = 0L),
    transform = FALSE
  )
  if (isTRUE(x = do.adt)) {
    output$imputedlabel <- renderUI(expr = h3('Imputed protein biomarkers'))
  } else {
    for (id in c('imputedinput', 'imputedtable', 'imputeddl')) {
      removeUI(selector = paste0('#', id), immediate = TRUE)
    }
    for (id in c('featureinput', 'scoreinput')) {
      removeClass(id = id, class = 'thirds')
      addClass(id = id, class = 'halves')
    }
    removeClass(id = 'biotable', class = 'halves')
    addClass(id = 'biotable', class = 'fulls')
  }
  ResetEnv <- function() {
    app.env$messages <- NULL
    output$valubox.upload <- NULL
    output$valuebox.preproc <- NULL
    output$valuebox.mapped <- NULL
    disable(id = 'map')
    hide(selector = '.rowhide')
  }
  rna.proxy <- dataTableProxy(outputId = 'biomarkers')
  adt.proxy <- dataTableProxy(outputId = 'adtbio')
  logging <- all(vapply(
    X = paste0('Azimuth.app.google', c('sheet', 'token', 'tokenemail')),
    FUN = function(x) {
      return(!is.null(x = getOption(x = x)))
    },
    FUN.VALUE = logical(length = 1L)
  ))
  if (logging) {
    tryCatch(
      expr = {
        gs4_auth(
          email = getOption(x = "Azimuth.app.googletokenemail"),
          cache = getOption(x = "Azimuth.app.googletoken")
        )
        googlesheet <- gs4_get(ss = getOption(x = "Azimuth.app.googlesheet"))
        app_start_time <- Sys.time()
        app_session_id <- paste0(Sys.info()[["nodename"]], as.numeric(Sys.time()))
        onStop(
          fun = function() {
            try(expr = sheet_append(
              ss = googlesheet,
              data = data.frame(
                "SESSIONLENGTH",
                app_session_id,
                as.numeric(x = Sys.time() - app_start_time, units = "mins")
              )
            ))
          }
        )
      },
      error = function(e) {
        googlesheet <- NULL
      }
    )
  } else {
    googlesheet <- NULL
  }
  if (!is.null(x = googlesheet)) {
    try(expr = sheet_append(
      ss = googlesheet,
      data = data.frame(
        "STARTUPTIME",
        app_session_id,
        Sys.time()
      )
    ))
  }
  withProgress(
    message = "Loading reference",
    expr = {
      setProgress(value = 0)
      refs <- LoadReference(
        path = getOption(
          x = 'Azimuth.app.reference',
          default = stop(safeError(error = "No reference provided"))
        )
      )
      setProgress(value = 1)
    }
  )
  if (!is.null(x = googlesheet)) {
    try(
      expr = sheet_append(
        ss = googlesheet,
        data = data.frame(
          c('REFERENCE_NAME', "REFERENCE_VERSION"),
          c(app_session_id, app_session_id),
          c(basename(getOption(x = 'Azimuth.app.reference')),  ReferenceVersion(object = refs$map))
        )
      ),
      silent = TRUE
    )
  }
  plotseed <- getOption(x = "Azimuth.app.plotseed")
  if (!is.null(x = plotseed)) {
    set.seed(seed = plotseed)
    colormap <- GetColorMap(object = refs$map)
    for (i in names(x = colormap)) {
      names(x = colormap[[i]]) <- sample(x = names(x = colormap[[i]]))
    }
    refs$map <- SetColorMap(object = refs$map, value = colormap)
  }
  possible.metadata.transfer <- names(x = GetColorMap(object = refs$map))
  if (length(x = possible.metadata.transfer) > 1) {
    react.env$xferopts <- TRUE
  }
  # React to events
  # Load the data an prepare for QC
  observeEvent(
    eventExpr = input$file,
    handlerExpr = {
      if (nchar(x = input$file$datapath)) {
        react.env$path <- input$file$datapath
      }
    }
  )
  observeEvent(
    eventExpr = input$triggerdemo,
    handlerExpr = react.env$path <- getOption(x = 'Azimuth.app.demodataset')
  )
  observeEvent(
    eventExpr = react.env$path,
    handlerExpr = {
      if (!is.null(x = react.env$path) && nchar(x = react.env$path)) {
        ResetEnv()
        withProgress(
          message = 'Reading Input',
          expr = {
            setProgress(value = 0)
            tryCatch(
              expr = {
                app.env$object <- LoadFileInput(path = react.env$path)
                if (react.env$path == getOption(x = 'Azimuth.app.demodataset')) {
                  app.env$demo <- TRUE
                } else {
                  app.env$demo <- FALSE
                }
                app.env$object$query <- 'query'
                Idents(object = app.env$object) <- 'query'

                app.env$default.assay <- DefaultAssay(object = app.env$object)
                react.env$mt <- any(grepl(
                  pattern = mito.pattern,
                  x = rownames(x = app.env$object)
                ))
                if (isFALSE(x = react.env$mt)) {
                  removeUI(selector = '#pctmt', immediate = TRUE)
                }
                common.features <- intersect(
                  x = rownames(x = app.env$object),
                  y = rownames(x = refs$map)
                )
                reject <- c(
                  length(x = common.features) < getOption(x = 'Azimuth.map.ngenes'),
                  length(x = Cells(x = app.env$object)) > getOption(x = 'Azimuth.app.max_cells')
                )
                if (any(reject)) {
                  app.env$object <- NULL
                  gc(verbose = FALSE)
                  reject <- min(which(x = reject))
                  app.env$messages <- paste(
                    c(
                      'Not enough genes in common with reference.',
                      'Too many cells.'
                    ),
                    'Try another dataset.'
                  )[reject]
                }
                if (isFALSE(x = react.env$xferopts)) {
                  removeUI(selector = '#xferopts', immediate = TRUE)
                }
                react.env$qc <- !any(reject)
                react.env$path <- NULL
              },
              error = function(e) {
                app.env$messages <- e$message
                safeError(error = e$message)
                app.env$object <- NULL
                gc(verbose = FALSE)
                if (isFALSE(x = react.env$xferopts)) {
                  removeUI(selector = '#xferopts', immediate = TRUE)
                }
                react.env$path <- NULL
              }
            )
            setProgress(value = 1)
          }
        )
        app.env$default.assay <- DefaultAssay(object = app.env$object)
        react.env$mt <- any(grepl(
          pattern = mito.pattern,
          x = rownames(x = app.env$object)
        ))
        if (isFALSE(x = react.env$mt)) {
          removeUI(selector = '#pctmt', immediate = TRUE)
        }
        common.features <- intersect(
          x = rownames(x = app.env$object),
          y = rownames(x = refs$map)
        )
        reject <- c(
          length(x = common.features) < getOption(x = 'Azimuth.map.ngenes'),
          length(x = Cells(x = app.env$object)) > getOption(x = 'Azimuth.app.max_cells')
        )
        if (any(reject)) {
          app.env$object <- NULL
          gc(verbose = FALSE)
          reject <- min(which(x = reject))
          app.env$messages <- paste(
            c(
              'Not enough genes in common with reference.',
              'Too many cells.'
            ),
            'Try another dataset.'
          )[reject]
        }
        if (isFALSE(x = react.env$xferopts)) {
          removeUI(selector = '#xferopts', immediate = TRUE)
        }
        react.env$qc <- !any(reject)
        react.env$path <- NULL
      }
    }
  )
  observeEvent(
    eventExpr = react.env$qc,
    handlerExpr = {
      if (isTRUE(x = react.env$qc)) {
        for (id in qc.ids) {
          try(expr = enable(id = id), silent = TRUE)
        }
        ncount <- paste0('nCount_', app.env$default.assay)
        nfeature <- paste0('nFeature_', app.env$default.assay)
        if (!all(c(ncount, nfeature) %in% colnames(x = app.env$object[[]]))) {
          withProgress(
            message = 'Calculating nCount and nFeature',
            expr = {
              setProgress(value = 0)
              calcn <- as.data.frame(x = Seurat:::CalcN(object = app.env$object))
              colnames(x = calcn) <- paste(
                colnames(x = calcn),
                app.env$default.assay,
                sep = '_'
              )
              app.env$object <- AddMetaData(
                object = app.env$object,
                metadata = calcn
              )
              rm(calcn)
              gc(verbose = FALSE)
              setProgress(value = 1)
            }
          )
        }
        ncount.val <- range(app.env$object[[ncount, drop = TRUE]])
        ncount.val <- c(
          floor(x = min(ncount.val)),
          ceiling(x = max(ncount.val))
        )
        updateNumericInput(
          session = session,
          inputId = 'num.ncountmin',
          label = paste('min', ncount),
          value = ncount.val[1],
          min = ncount.val[1],
          max = ncount.val[2]
        )
        updateNumericInput(
          session = session,
          inputId = 'num.ncountmax',
          label = paste('max', ncount),
          value = ncount.val[2],
          min = ncount.val[1],
          max = ncount.val[2]
        )
        nfeature.val <- range(app.env$object[[nfeature, drop = TRUE]])
        nfeature.val <- c(
          floor(x = min(nfeature.val)),
          ceiling(x = max(nfeature.val))
        )
        updateNumericInput(
          session = session,
          inputId = 'num.nfeaturemin',
          label = paste('min', nfeature),
          value = nfeature.val[1],
          min = nfeature.val[1],
          max = nfeature.val[2]
        )
        updateNumericInput(
          session = session,
          inputId = 'num.nfeaturemax',
          label = paste('max', nfeature),
          value = nfeature.val[2],
          min = nfeature.val[1],
          max = nfeature.val[2]
        )
        if (isTRUE(x = react.env$mt)) {
          app.env$object <- PercentageFeatureSet(
            object = app.env$object,
            pattern = mito.pattern,
            col.name = mt.key,
            assay = app.env$default.assay
          )
          mito.val <- range(app.env$object[[mt.key, drop = TRUE]])
          mito.val <- c(
            floor(x = min(mito.val)),
            ceiling(x = max(mito.val))
          )
          updateNumericInput(
            session = session,
            inputId = 'minmt',
            label = paste('min', mt.key),
            value = mito.val[1],
            min = mito.val[1],
            max = mito.val[2]
          )
          updateNumericInput(
            session = session,
            inputId = 'maxmt',
            label = paste('max', mt.key),
            value = mito.val[2],
            min = mito.val[1],
            max = mito.val[2]
          )
        }
        output$menu1 <- renderMenu(expr = {
          sidebarMenu(menuItem(
            text = 'Preprocessing',
            tabName = 'tab_preproc',
            icon = icon(name = 'filter'),
            selected = TRUE
          ))
        })
        ncellsupload <- length(x = colnames(x = app.env$object))
        app.env$ncellsupload <- ncellsupload
        app.env$messages <- paste(ncellsupload, 'cells uploaded')
        if (ncellsupload < getOption(x = 'Azimuth.map.ncells')) {
          output$valuebox.upload <- renderValueBox(expr = {
            valueBox(
              value = ncellsupload,
              subtitle = 'cells uploaded',
              icon = icon(name = 'times'),
              color = 'red'
            )
          })
        } else {
          output$valuebox.upload <- renderValueBox(expr = {
            valueBox(
              value = ncellsupload,
              subtitle = 'cells uploaded',
              icon = icon(name = 'check'),
              color = 'green'
            )
          })
          if (!is.null(x = googlesheet)) {
            try(
              expr = sheet_append(
                ss = googlesheet,
                data = data.frame(
                  'CELLSUPLOAD',
                  app_session_id,
                  ncellsupload
                )
              ),
              silent = TRUE
            )
          }
        }
        if (!is.null(x = react.env$progress)) {
          react.env$progress$close()
          react.env$progress <- NULL
        }
        default_xfer <- getOption(x = "Azimuth.app.default_metadata", default = possible.metadata.transfer[1])
        if (!default_xfer %in% possible.metadata.transfer) {
          default_xfer <- possible.metadata.transfer[1]
        }
        updateSelectizeInput(
          session = session,
          inputId = 'metadataxfer',
          choices = possible.metadata.transfer,
          selected = default_xfer,
          server = TRUE,
          options = selectize.opts[-which(x = names(x = selectize.opts) == 'maxItems')]
        )
        react.env$qc <- FALSE
      }
    }
  )
  observeEvent(
    eventExpr = input$metadataxfer,
    handlerExpr = {
      if (length(x = input$metadataxfer) == 0) {
        disable(id = 'map')
      } else {
        enable(id = 'map')
      }
    },
    ignoreNULL = FALSE
  )
  # Filter and process the data
  observeEvent(
    eventExpr = input$map,
    handlerExpr = {
      react.env$start <- Sys.time()
      for (id in qc.ids) {
        try(expr = disable(id = id), silent = TRUE)
      }
      react.env$progress <- Progress$new(style = 'notification')
      react.env$progress$set(
        value = 0,
        message = 'Filtering based on nCount and nFeature'
      )
      ncount <- paste0('nCount_', DefaultAssay(object = app.env$object))
      nfeature <- paste0('nFeature_', DefaultAssay(object = app.env$object))
      cells.use <- app.env$object[[ncount, drop = TRUE]] >= input$num.ncountmin &
        app.env$object[[ncount, drop = TRUE]] <= input$num.ncountmax &
        app.env$object[[nfeature, drop = TRUE]] >= input$num.nfeaturemin &
        app.env$object[[nfeature, drop = TRUE]] <= input$num.nfeaturemax
      if (isTRUE(x = react.env$mt)) {
        cells.use <- cells.use &
          app.env$object[[mt.key, drop = TRUE]] >= input$minmt &
          app.env$object[[mt.key, drop = TRUE]] <= input$maxmt
      }
      ncellspreproc <- sum(cells.use)
      app.env$ncellspreproc <- ncellspreproc
      # not enough cells available after filtering: reset filter elements
      if (ncellspreproc < getOption(x = "Azimuth.map.ncells")) {
        output$valuebox.preproc <- renderValueBox(expr = valueBox(
          value = ncellspreproc,
          subtitle = "cells after filtering",
          icon = icon("times"),
          color = "red"
        ))
        react.env$qc <- TRUE
      } else {
        output$valuebox.preproc <- renderValueBox(expr = valueBox(
          value = ncellspreproc,
          subtitle = "cells after filtering",
          icon = icon("check"),
          color = "green"
        ))
        if (!is.null(googlesheet)) {
          try(sheet_append(
            ss = googlesheet,
            data = data.frame(
              "CELLSPREPROC",
              app_session_id,
              ncellspreproc
            )
          ))
        }
        app.env$object <- app.env$object[, cells.use]
        react.env$pbcor <- TRUE
      }
    }
  )
  observeEvent(
    eventExpr = react.env$pbcor,
    handlerExpr = {
      if (isTRUE(x = react.env$pbcor)) {
        react.env$progress$set(
          value = 0.1,
          message = 'Running pseudobulk correlation test'
        )
        pbcor <- PBCorTest(
          object = app.env$object,
          ref = refs$avg
        )
        if (!is.null(googlesheet)) {
          try(sheet_append(
            ss = googlesheet,
            data = data.frame(
              "PBCOR",
              app_session_id,
              pbcor[["cor.res"]]
            )
          ))
        }
        if (pbcor[["cor.res"]] < getOption(x = 'Azimuth.map.pbcorthresh')) {
          output$valuebox.mapped <- renderValueBox(expr = {
            valueBox(
              value = 'Failure',
              subtitle = 'Query is too dissimilar',
              icon = icon(name = 'times'),
              color = 'red',
              width = 6
            )
          })
          output$plot.pbcor <- renderPlot(expr = pbcor[['plot']])
          show(selector = ".rowhide")
          app.env$object <- NULL
          react.env$progress$close()
          gc(verbose = FALSE)
        } else {
          react.env$sctransform <- TRUE
        }
        react.env$pbcor <- FALSE
      }
    }
  )
  observeEvent(
    eventExpr = react.env$sctransform,
    handlerExpr = {
      if (isTRUE(x = react.env$sctransform)) {
        react.env$progress$set(
          value = 0.2,
          message = 'Normalizing with SCTransform'
        )
        tryCatch(
          expr = {
            app.env$object <- suppressWarnings(expr = SCTransform(
              object = app.env$object,
              residual.features = rownames(x = refs$map),
              reference.SCT.model = slot(object = refs$map[["refAssay"]], name = "SCTModel.list")[["refmodel"]],
              method = "glmGamPoi",
              do.correct.umi = FALSE,
              do.scale = FALSE,
              do.center = TRUE,
              new.assay.name = "refAssay"
            ))
          },
          error = function(e) {
            app.env$object <- suppressWarnings(expr = SCTransform(
              object = app.env$object,
              residual.features = rownames(x = refs$map),
              reference.SCT.model = slot(object = refs$map[["refAssay"]], name = "SCTModel.list")[["refmodel"]],
              method = "poisson",
              do.correct.umi = FALSE,
              do.scale = FALSE,
              do.center = TRUE,
              new.assay.name = "refAssay"
            ))
          }
        )
        app.env$messages <- c(
          app.env$messages,
          paste(ncol(x = app.env$object), "cells preprocessed")
        )
        react.env$anchors <- TRUE
        react.env$sctransform <- FALSE
      }
    }
  )
  observeEvent(
    eventExpr = react.env$anchors,
    handlerExpr = {
      if (isTRUE(x = react.env$anchors)) {
        react.env$progress$set(value = 0.3, message = 'Finding anchors')
        app.env$anchors <- FindTransferAnchors(
          reference = refs$map,
          query = app.env$object,
          k.filter = NA,
          reference.neighbors = "refdr.annoy.neighbors",
          reference.assay = "refAssay",
          query.assay = 'refAssay',
          reference.reduction = 'refDR',
          normalization.method = 'SCT',
          features = intersect(
            x = rownames(x = refs$map),
            y = VariableFeatures(object = app.env$object)
          ),
          dims = 1:50,
          n.trees = n.trees,
          verbose = TRUE,
          mapping.score.k = 100
        )
        nanchors <- nrow(x = slot(object = app.env$anchors, name = "anchors"))
        output$valuebox.nanchors <- renderValueBox(expr = {
          valueBox(
            value = nanchors,
            subtitle = "Total Anchors",
            color = 'blue'
          )
        })
        if (nanchors < getOption(x = 'Azimuth.map.nanchors')) {
          output$valuebox.mapped <- renderValueBox(expr = {
            valueBox(
              value = 'Failure',
              subtitle = paste0('Too few anchors identified (', nanchors, ')'),
              icon = icon(name = 'times'),
              color = 'red',
              width = 6
            )
          })
          app.env$object <- NULL
          app.env$anchors <- NULL
          react.env$progress$close()
          gc(verbose = FALSE)
        } else {
          react.env$map <- TRUE
        }
        react.env$anchors <- FALSE
      }
    }
  )
  observeEvent(
    eventExpr = react.env$map,
    handlerExpr = {
      if (isTRUE(x = react.env$map)) {
        if (is.null(x = input$metadataxfer)) {
          app.env$metadataxfer <- names(x = GetColorMap(object = refs$map))
        } else {
          app.env$metadataxfer <- input$metadataxfer
        }
        react.env$progress$set(value = 0.5, message = 'Mapping cells')
        refdata <- lapply(X = app.env$metadataxfer, function(x) {
          refs$map[[x, drop = TRUE]]
        })
        names(x = refdata) <- app.env$metadataxfer
        if (do.adt) {
          refdata[["impADT"]] <- GetAssayData(
            object = refs$map[['ADT']],
            slot = 'data'
          )
        }
        app.env$object <- TransferData(
          reference = refs$map,
          query = app.env$object,
          dims = 1:50,
          anchorset = app.env$anchors,
          refdata = refdata,
          n.trees = n.trees,
          store.weights = TRUE
        )
        for(i in app.env$metadataxfer) {
          app.env$object[[paste0("predicted.", i), drop = TRUE]] <- factor(
            x = app.env$object[[paste0("predicted.", i), drop = TRUE]],
            levels = levels(x = refs$map[[i, drop = TRUE]])
          )
        }
        app.env$object <- IntegrateEmbeddings(
          anchorset = app.env$anchors,
          reference = refs$map,
          query = app.env$object,
          reductions = "pcaproject",
          reuse.weights.matrix = TRUE
        )
        if (is.null(x = getOption(x = "Azimuth.app.default_metadata"))) {
          app.env$default.metadata <- names(x = refdata)[1]
        } else {
          if (getOption(x = "Azimuth.app.default_metadata") %in% names(x = refdata)) {
            app.env$default.metadata <- getOption(x = "Azimuth.app.default_metadata")
          } else {
            app.env$default.metadata <- names(x = refdata)[1]
          }
        }
        react.env$score <- TRUE
        react.env$map <- FALSE
      }
    }
  )
  observeEvent(
    eventExpr = react.env$score,
    handlerExpr = {
      if (isTRUE(x = react.env$score)) {
        react.env$progress$set(
          value = 0.7,
          message = 'Calculating mapping score'
        )
        # post mapping QC
        app.env$query.qc <- MappingQCMetric(query = app.env$object)
        qc.stat <- round(x = Misc(object = app.env$query.qc, slot = "mapping.qc")$stat, digits = 3)
        output$valuebox.mappingqcstat <- renderValueBox(expr = {
          valueBox(
            value = qc.stat,
            subtitle = "Mapping QC Stat",
            color = ifelse(test = qc.stat < 0.2, yes = "green", no = "orange"),
            icon = icon(name = ifelse(test = qc.stat < 0.2, yes = "check", no = "exclamation-circle"))
          )
        })
        refdr <- subset(
          x = app.env$anchors@object.list[[1]][["pcaproject.l2"]],
          cells = paste0(Cells(x = app.env$object), "_query")
        )
        refdr <- RenameCells(
          object = refdr,
          new.names = Cells(x = app.env$object)
        )
        refdr.ref <- subset(
          x = app.env$anchors@object.list[[1]][["pcaproject.l2"]],
          cells = paste0(Cells(x = refs$map), "_reference")
        )
        refdr.ref <- RenameCells(
          object = refdr.ref,
          new.names = Cells(x = refs$map)
        )
        if (Sys.getenv("RSTUDIO") == "1") {
          plan("sequential")
        }
        # reduce size of object in anchorset
        app.env$anchors@object.list[[1]] <- DietSeurat(
          object = app.env$anchors@object.list[[1]]
        )
        app.env$anchors@object.list[[1]] <- subset(
          x = app.env$anchors@object.list[[1]],
          features = c(rownames(x = app.env$anchors@object.list[[1]])[1])
        )
        app.env$anchors@object.list[[1]] <- RenameCells(
          object = app.env$anchors@object.list[[1]],
          new.names = unname(obj = sapply(
            X = Cells(x = app.env$anchors@object.list[[1]]),
            FUN = function(x) {
              return(gsub(pattern = "_reference", replacement = "", x = x))
            }
          )))
        app.env$anchors@object.list[[1]] <- RenameCells(
          object = app.env$anchors@object.list[[1]],
          new.names = sapply(
            X = Cells(x = app.env$anchors@object.list[[1]]),
            FUN = function(x) {
              return(gsub(pattern = "_query", replacement = "", x = x))
            },
            USE.NAMES = FALSE
          )
        )
        app.env$anchors@object.list[[1]]@meta.data <- data.frame()
        app.env$anchors@object.list[[1]]@active.ident <- factor()
        app.env$mapping.score <- future(
          expr = {
            MappingScore(
              anchors = app.env$anchors@anchors,
              combined.object = app.env$anchors@object.list[[1]],
              query.neighbors =  slot(object = app.env$anchors, name = "neighbors")[["query.neighbors"]],
              query.weights = Tool(object = app.env$object, slot = "TransferData")$weights.matrix,
              query.embeddings = Embeddings(object = refdr),
              ref.embeddings = Embeddings(object = refdr.ref),
              nn.method = "annoy",
              n.trees = n.trees
            )
          }
        )
        app.env$object <- AddMetaData(
          object = app.env$object,
          metadata = rep(x = 0, times = ncol(x = app.env$object)),
          col.name = "mapping.score"
        )
        app.env$anchors <- NULL
        rm(refdr)
        gc(verbose = FALSE)
        react.env$transform <- TRUE
        react.env$score <- FALSE
      }
    }
  )
  observeEvent(
    eventExpr = react.env$transform,
    handlerExpr = {
      if (isTRUE(x = react.env$transform)) {
        react.env$progress$set(value = 0.8, message = 'Running UMAP transform')
        app.env$object[["query_ref.nn"]] <- FindNeighbors(
          object = Embeddings(refs$map[["refDR"]]),
          query = Embeddings(app.env$object[["integrated_dr"]]),
          return.neighbor = TRUE,
          l2.norm = TRUE,
          n.trees = n.trees
        )
        app.env$object <- NNTransform(
          object = app.env$object,
          meta.data = refs$map[[]]
        )
        app.env$object[['umap.proj']] <- RunUMAP(
          object = app.env$object[['query_ref.nn']],
          reduction.model = refs$map[['refUMAP']],
          reduction.key = 'UMAP_'
        )
        app.env$object <- SetAssayData(
          object = app.env$object,
          assay = 'refAssay',
          slot = 'scale.data',
          new.data = new(Class = 'matrix')
        )
        gc(verbose = FALSE)
        app.env$messages <- c(
          app.env$messages,
          paste(ncol(x = app.env$object), "cells mapped")
        )
        if (Misc(object = app.env$query.qc, slot = "mapping.qc")$stat < 0.2){
          output$valuebox.mapped <- renderValueBox(expr = {
            valueBox(
              value = 'Success',
              subtitle = 'Mapping complete',
              icon = icon(name = 'check'),
              color = 'green'
            )
          })
        }
        else {
          output$valuebox.mapped <- renderValueBox(expr = {
            valueBox(
              value = 'Warning',
              subtitle = 'Mapping complete',
              icon = icon(name = 'exclamation-circle'),
              color = 'orange'
            )
          })
        }
        react.env$biomarkers <- TRUE
        react.env$transform <- FALSE
      }
    }
  )
  observeEvent(
    eventExpr = react.env$biomarkers,
    handlerExpr = {
      if (isTRUE(x = react.env$biomarkers)) {
        react.env$progress$set(
          value = 0.95,
          message = 'Running differential expression'
        )
        for (i in app.env$metadataxfer) {
          app.env$diff.expr[[paste(app.env$default.assay, i, sep = "_")]] <- wilcoxauc(
            X = app.env$object,
            group_by = paste0("predicted.", i),
            assay = 'data',
            seurat_assay = app.env$default.assay
          )
          if (isTRUE(x = do.adt)) {
            app.env$diff.expr[[paste(adt.key, i, sep = "_")]] <- wilcoxauc(
              X = app.env$object,
              group_by = paste0("predicted.", i),
              assay = 'data',
              seurat_assay = adt.key
            )
          }
        }

        # Finalize the log
        mapping.time <- difftime(
          time1 = Sys.time(),
          time2 = react.env$start,
          units = 'secs'
        )
        time.fmt <- FormatDiffTime(dt = mapping.time)
        app.env$messages <- c(
          app.env$messages,
          time.fmt
        )
        if (!is.null(x = googlesheet)) {
          try(expr = sheet_append(
            ss = googlesheet,
            data = data.frame(
              "MAPPINGTIME",
              app_session_id,
              as.numeric(x = mapping.time)
            )
          ))
        }
        if (!is.null(x = googlesheet)) {
          try(
            expr = sheet_append(
              ss = googlesheet,
              data = data.frame(
                "SUMMARY",
                app_session_id,
                basename(getOption(x = 'Azimuth.app.reference')),
                ReferenceVersion(object = refs$map),
                app.env$demo,
                app.env$ncellsupload,
                app.env$ncellspreproc,
                as.numeric(x = mapping.time),
                Sys.Date()
              )
            ),
            silent = TRUE
          )
        }
        output$menu2 <- renderMenu(expr = {
          sidebarMenu(
            menuItem(
              text = "Cell Plots",
              tabName = "tab_cell",
              icon = icon("chart-area")
            ),
            menuItem(
              text = "Feature Plots",
              tabName = "tab_feature",
              icon = icon("chart-area")
            ),
            menuItem(
              text = "Mapping QC",
              tabName = "tab_mappingqc",
              icon = icon("chart-area")
            ),
            menuItem(
              text = "Download Results",
              tabName = "tab_download",
              icon = icon("file-download")
            )
          )
        })
        react.env$progress$close()
        react.env$metadata <- TRUE
        react.env$biomarkers <- FALSE
      }
    }
  )
  # Update input controls
  observeEvent(
    eventExpr = react.env$metadata,
    handlerExpr = {
      if (isTRUE(x = react.env$metadata)) {
        #  Add the discrete metadata dropdowns
        metadata.discrete <- sort(x =
                                    PlottableMetadataNames(
                                      object = app.env$object,
                                      exceptions = app.env$metadataxfer,
                                      min.levels = 1,
                                      max.levels = 50
                                    )
        )
        for (id in c('metarow', 'metacol', 'metagroup')) {
          if (id == 'metarow') {
            matches <- grep(
              pattern = 'celltype|label|annotation',
              x = metadata.discrete,
              value = T,
              ignore.case = T
            )
            matches <- grep(
              pattern = 'predicted',
              x = matches,
              value = T,
              invert = T
            )
            show.metadata <- (
              if (length(x = matches) > 0) {
                count.na <- sapply(X = matches, FUN = function(m) {
                  sum(FetchData(object = app.env$object, vars = m)[,1] %in% c(NA, ''))
                })
                matches[which.min(x = count.na)]
              } else {
                'query'
              }
            )
          } else {
            show.metadata <- paste0("predicted.", app.env$default.metadata)
          }
          updateSelectizeInput(
            session = session,
            inputId = id,
            choices = metadata.discrete,
            selected = show.metadata,
            server = TRUE,
            options = selectize.opts
          )
        }
        updateSelectizeInput(
          session = session,
          inputId = 'metacolor.query',
          choices = metadata.discrete,
          selected = paste0("predicted.", app.env$default.metadata),
          server = TRUE,
          options = selectize.opts[-which(x = names(x = selectize.opts) == 'maxItems')]
        )
        # Add the continuous metadata dropdown
        metadata.cont <- sort(x = setdiff(
          x = colnames(x = app.env$object[[]]),
          y = metadata.discrete
        ))
        metadata.cont <- Filter(
          f = function(x) {
            return(is.numeric(x = app.env$object[[x, drop = TRUE]]))
          },
          x = metadata.cont
        )
        # Add prediction scores for all classes to continuous metadata
        metadata.cont <- sort(x = metadata.cont)
        app.env$metadata.cont <- metadata.cont
        updateSelectizeInput(
          session = session,
          inputId = 'metadata.cont',
          choices = app.env$metadata.cont,
          selected = '',
          server = TRUE,
          options = selectize.opts
        )
        updateSelectizeInput(
          session = session,
          inputId = 'scoregroup',
          choices = paste0("predicted.", app.env$metadataxfer),
          selected = app.env$default.metadata,
          server = TRUE,
          options = selectize.opts
        )
        if (!input$scoregroup == "") {
          predscores <- sort(x = rownames(x = app.env$object[[paste0("prediction.score.", input$scoregroup)]]))
          updateSelectizeInput(
            session = session,
            inputId = 'scorefeature',
            choices = predscores,
            selected = predscores[1],
            server = TRUE,
            options = selectize.opts
          )
        }
        updateSelectizeInput(
          session = session,
          inputId = 'metacolor.ref',
          choices = app.env$metadataxfer,
          selected = app.env$default.metadata,
          server = TRUE,
          options = selectize.opts[-which(x = names(x = selectize.opts) == 'maxItems')]
        )
        updateSelectizeInput(
          session = session,
          inputId = 'query.qc.meta',
          choices = paste0("predicted.", app.env$metadataxfer),
          selected = paste0("predicted.", app.env$default.metadata),
          server = TRUE,
          options = selectize.opts[-which(x = names(x = selectize.opts) == 'maxItems')]
        )
        react.env$features <- TRUE
        react.env$metadata <- FALSE
      }
    }
  )
  observeEvent(
    eventExpr = react.env$features,
    handlerExpr = {
      if (isTRUE(x = react.env$features)) {
        app.env$default.feature <- ifelse(
          test = getOption(x = 'Azimuth.app.default_gene') %in% rownames(x = app.env$object),
          yes = getOption(x = 'Azimuth.app.default_gene'),
          no = VariableFeatures(object = app.env$object)[1]
        )
        app.env$features <- FilterFeatures(
          features = rownames(x = app.env$object)
        )
        updateSelectizeInput(
          session = session,
          inputId = 'feature',
          label = 'Feature',
          choices = app.env$features,
          selected = app.env$default.feature,
          server = TRUE,
          options = selectize.opts
        )
        if (isTRUE(x = do.adt)) {
          app.env$adt.features <- sort(x = FilterFeatures(features = rownames(
            x = app.env$object[[adt.key]]
          )))
          updateSelectizeInput(
            session = session,
            inputId = 'adtfeature',
            choices = app.env$adt.features,
            selected = '',
            server = TRUE,
            options = selectize.opts
          )
        }
        react.env$markers <- TRUE
        react.env$features <- FALSE
      }
    }
  )

  observeEvent(
    eventExpr = react.env$markers,
    handlerExpr = {
      if (isTRUE(x = react.env$markers)) {
        allowed.clusters <- names(x = which(
          x = table(app.env$object[[paste0("predicted.", app.env$default.metadata)]]) > getOption(x = 'Azimuth.de.mincells')
        ))
        allowed.clusters <- factor(
          x = allowed.clusters,
          levels = unique(x = app.env$object[[paste0("predicted.", app.env$default.metadata), drop = TRUE]])
        )
        allowed.clusters <- sort(x = levels(x = droplevels(x = na.omit(
          object = allowed.clusters
        ))))
        # updateSelectizeInput(
        #   session = session,
        #   inputId = 'select.prediction',
        #   choices = allowed.clusters,
        #   selected = allowed.clusters[1],
        #   server = TRUE,
        #   options = selectize.opts
        # )

        updateSelectizeInput(
          session = session,
          inputId = 'markerclusters',
          choices = allowed.clusters,
          selected = allowed.clusters[1],
          server = TRUE,
          options = selectize.opts
        )

        updateSelectizeInput(
          session = session,
          inputId = 'markerclustersgroup',
          choices = app.env$metadataxfer,
          selected = app.env$default.metadata,
          server = TRUE,
          options = selectize.opts
        )

        react.env$markers <- FALSE
      }
    }
  )
  observeEvent(
    eventExpr = react.env$no,
    handlerExpr = {
      if (FALSE) {
        # Enable the feature explorer

        # Add the predicted ID and score to the plots



        # Enable downloads


        react.env$no <- FALSE
      }
    }
  )
  # Handle input changes
  observeEvent( # RNA feature
    eventExpr = input$feature,
    handlerExpr = {
      if (nchar(x = input$feature)) {
        app.env$feature <- ifelse(
          test = input$feature %in% rownames(x = app.env$object),
          yes = paste0(
            Key(object = app.env$object[["refAssay"]]),
            input$feature
          ),
          no = input$feature
        )
        for (f in c('adtfeature', 'metadata.cont', 'scoregroup', 'scorefeature')) {
          updateSelectizeInput(
            session = session,
            inputId = f,
            choices = list(
              'adtfeature' = app.env$adt.features,
              'metadata.cont' = app.env$metadata.cont,
              'scoregroup' = app.env$metadataxfer,
              'scorefeature' = ''
            )[[f]],
            selected = '',
            server = TRUE,
            options = selectize.opts
          )
        }
        table.check <- input$feature %in% rownames(x = RenderDiffExp(
          diff.exp = app.env$diff.expr[[paste(app.env$default.assay, app.env$default.metadata, sep = "_")]],
          groups.use = input$markerclusters,
          n = Inf
        ))
        tables.clear <- list(adt.proxy, rna.proxy)[c(TRUE, !table.check)]
        for (tab in tables.clear) {
          selectRows(proxy = tab, selected = NULL)
        }
      }
    }
  )
  observeEvent( # Protein feature
    eventExpr = input$adtfeature,
    handlerExpr = {
      if (nchar(x = input$adtfeature)) {
        app.env$feature <- paste0(
          Key(object = app.env$object[[adt.key]]),
          input$adtfeature
        )
        for (f in c('feature', 'metadata.cont', 'scoregroup', 'scorefeature')) {
          updateSelectizeInput(
            session = session,
            inputId = f,
            choices = list(
              'feature' = app.env$features,
              'metadata.cont' = app.env$metadata.cont,
              'scoregroup' = app.env$metadataxfer,
              'scorefeature' = ''
            )[[f]],
            selected = '',
            server = TRUE,
            options = selectize.opts
          )
        }
        table.check <- input$adtfeature %in% rownames(x = RenderDiffExp(
          diff.exp = app.env$diff.expr[[paste(adt.key, input$markerclustersgroup, sep = "_")]],
          groups.use = input$markerclusters,
          n = Inf
        ))
        tables.clear <- list(rna.proxy, adt.proxy)[c(TRUE, !table.check)]
        for (tab in tables.clear) {
          selectRows(proxy = tab, selected = NULL)
        }
      }
    }
  )
  observeEvent( # Continuous Metadata
    eventExpr = input$metadata.cont,
    handlerExpr = {
      if (nchar(x = input$metadata.cont)) {
        if (input$metadata.cont == "mapping.score") {
          if (resolved(x = app.env$mapping.score)) {
            app.env$object$mapping.score <- value(app.env$mapping.score)
          }
        }
        app.env$feature <- input$metadata.cont
        for (f in c('feature', 'adtfeature', 'scoregroup', 'scorefeature')) {
          updateSelectizeInput(
            session = session,
            inputId = f,
            choices = list(
              'feature' = app.env$features,
              'adtfeature' = app.env$adt.features,
              'scoregroup' = app.env$metadataxfer,
              'scorefeature' = ''
            )[[f]],
            selected = '',
            server = TRUE,
            options = selectize.opts
          )
        }
        for (tab in list(rna.proxy, adt.proxy)) {
          selectRows(proxy = tab, selected = NULL)
        }
      }
    }
  )
  observeEvent( # Prediction score group
    eventExpr = input$scoregroup,
    handlerExpr = {
      if (nchar(x = input$scoregroup)) {
        app.env$feature <- ""
        for (f in c('feature', 'adtfeature', 'metadata.cont')) {
          updateSelectizeInput(
            session = session,
            inputId = f,
            choices = list(
              'feature' = app.env$features,
              'adtfeature' = app.env$adt.features,
              'metadata.cont' = app.env$metadata.cont
            )[[f]],
            selected = '',
            server = TRUE,
            options = selectize.opts
          )
        }
        predscores <- sort(x = rownames(x = app.env$object[[paste0("prediction.score.", input$scoregroup)]]))
        updateSelectizeInput(
          session = session,
          inputId = 'scorefeature',
          choices = predscores,
          selected = predscores[1],
          server = TRUE,
          options = selectize.opts
        )
      }
      for (tab in list(rna.proxy, adt.proxy)) {
        selectRows(proxy = tab, selected = NULL)
      }
    }
  )
  observeEvent( # Prediction score feature
    eventExpr = input$scorefeature,
    handlerExpr = {
      if (nchar(x = input$scorefeature)) {
        app.env$feature <- paste0(
          Key(object = app.env$object[[paste0("prediction.score.", input$scoregroup)]]),
          input$scorefeature
        )
      }
      for (f in c('feature', 'adtfeature', 'metadata.cont')) {
        updateSelectizeInput(
          session = session,
          inputId = f,
          choices = list(
            'feature' = app.env$features,
            'adtfeature' = app.env$adt.features,
            'metadata.cont' = app.env$metadata.cont
          )[[f]],
          selected = '',
          server = TRUE,
          options = selectize.opts
        )
      }
      for (tab in list(rna.proxy, adt.proxy)) {
        selectRows(proxy = tab, selected = NULL)
      }
    }
  )
  observeEvent( # Marker clusters group
    eventExpr = input$markerclustersgroup,
    handlerExpr = {
      if (nchar(x = input$markerclustersgroup)) {
        allowed.clusters <- names(x = which(
          x = table(app.env$object[[paste0("predicted.", input$markerclustersgroup)]]) > getOption(x = 'Azimuth.de.mincells')
        ))
        allowed.clusters <- factor(
          x = allowed.clusters,
          levels = unique(x = app.env$object[[paste0("predicted.", input$markerclustersgroup), drop = TRUE]])
        )
        allowed.clusters <- sort(x = levels(x = droplevels(x = na.omit(
          object = allowed.clusters
        ))))
        app.env$allowedclusters <- allowed.clusters
        updateSelectizeInput(
          session = session,
          inputId = "markerclusters",
          choices = app.env$allowedclusters,
          selected = app.env$allowedclusters[1],
          server = TRUE,
          options = selectize.opts
        )
      }
    }
  )

  observeEvent( # Select from biomarkers table
    eventExpr = input$biomarkers_rows_selected,
    handlerExpr = {
      if (length(x = input$biomarkers_rows_selected)) {
        updateSelectizeInput(
          session = session,
          inputId = 'feature',
          choices = app.env$features,
          selected = rownames(x = RenderDiffExp(
            diff.exp = app.env$diff.expr[[paste(app.env$default.assay, input$markerclustersgroup, sep = "_")]],
            groups.use = input$markerclusters,
            n = Inf
          ))[input$biomarkers_rows_selected],
          server = TRUE,
          options = selectize.opts
        )
      }
    }
  )
  observeEvent( # Select from adtbio table
    eventExpr = input$adtbio_rows_selected,
    handlerExpr = {
      if (length(x = input$adtbio_rows_selected)) {
        updateSelectizeInput(
          session = session,
          inputId = 'adtfeature',
          choices = app.env$adt.features,
          selected = rownames(x = RenderDiffExp(
            diff.exp = app.env$diff.expr[[paste(adt.key, input$markerclustersgroup, sep = "_")]],
            groups.use = input$markerclusters,
            n = Inf
          ))[input$adtbio_rows_selected],
          server = TRUE,
          options = selectize.opts
        )
      }
    }
  )
  # Plots
  output$plot.qc <- renderPlot(expr = {
    if (!is.null(x = isolate(app.env$object))) {
      qc <- paste0(c('nCount_', 'nFeature_'), app.env$default.assay)
      if (isTRUE(x = react.env$mt)) {
        qc <- c(qc, mt.key)
      }
      vlnlist <- VlnPlot(
        object = isolate(app.env$object),
        features = qc,
        group.by = 'query',
        combine = FALSE,
        pt.size = ifelse(
          test = input$check.qcpoints,
          yes = 0,
          no = Seurat:::AutoPointSize(data = isolate(app.env$object))
        ),
        log = input$check.qcscale
      )
      # nCount
      vlnlist[[1]] <- vlnlist[[1]] +
        geom_hline(yintercept = input$num.ncountmin) +
        geom_hline(yintercept = input$num.ncountmax) +
        annotate(
          geom = "rect",
          alpha = 0.2,
          fill = "red",
          ymin = input$num.ncountmax,
          ymax = Inf,
          xmin = 0.5,
          xmax = 1.5
        ) +
        annotate(
          geom = "rect",
          alpha = 0.2,
          fill = "red",
          ymin = ifelse(test = input$check.qcscale, yes = 0, no = -Inf),
          ymax = input$num.ncountmin,
          xmin = 0.5,
          xmax = 1.5
        ) +
        NoLegend() +
        xlab("")
      # nFeature
      vlnlist[[2]] <- vlnlist[[2]] +
        geom_hline(yintercept = input$num.nfeaturemin) +
        geom_hline(yintercept = input$num.nfeaturemax) +
        annotate(
          geom = "rect",
          alpha = 0.2,
          fill = "red",
          ymin = input$num.nfeaturemax,
          ymax = Inf,
          xmin = 0.5,
          xmax = 1.5
        ) +
        annotate(
          geom = "rect",
          alpha = 0.2,
          fill = "red",
          ymin = ifelse(test = input$check.qcscale, yes = 0, no = -Inf),
          ymax = input$num.nfeaturemin,
          xmin = 0.5,
          xmax = 1.5
        ) +
        NoLegend() +
        xlab("")
      if (react.env$mt) {
        vlnlist[[3]] <- vlnlist[[3]] +
          geom_hline(yintercept = input$minmt) +
          geom_hline(yintercept = input$maxmt) +
          annotate(
            geom = "rect",
            alpha = 0.2,
            fill = "red",
            ymin = input$maxmt,
            ymax = Inf,
            xmin = 0.5,
            xmax = 1.5
          ) +
          annotate(
            geom = "rect",
            alpha = 0.2,
            fill = "red",
            ymin = ifelse(test = input$check.qcscale, yes = 0, no = -Inf),
            ymax = input$minmt,
            xmin = 0.5,
            xmax = 1.5
          ) +
          NoLegend() +
          xlab("")
      }
      wrap_plots(vlnlist, ncol = length(x = vlnlist))
    }
  })
  output$refdim <- renderPlot(expr = {
    if (!is.null(x = input$metacolor.ref)) {
      colormaps <- GetColorMap(object = refs$map)[input$metacolor.ref]
      plots <- list()
      for (i in 1:length(x = colormaps)) {
        plots[[i]] <- DimPlot(
          object = refs$plot,
          label = input$labels,
          group.by = input$metacolor.ref[i],
          cols = colormaps[[i]],
          repel = TRUE,
        )
      }
      app.env$plot.ranges <- list(
        layer_scales(plots[[1]])$x$range$range,
        layer_scales(plots[[1]])$y$range$range
      )
      wrap_plots(plots, nrow = 1)
    }
  })
  output$objdim <- renderPlot(expr = {
    if (!is.null(x = app.env$object)) {
      if (length(x = Reductions(object = app.env$object)) & !is.null(x = input$metacolor.query)) {
        plots <- list()
        for (i in 1:length(x = input$metacolor.query)) {
          group.var <- gsub(pattern = "^predicted.", replacement = "", x = input$metacolor.query[i])
          colormap <- GetColorMap(object = refs$map)[[group.var]]
          if (!grepl(pattern = "^predicted.", x = input$metacolor.query[i])) {
            colormap <- NULL
          }
          plots[[i]] <- DimPlot(
            object = app.env$object,
            group.by = input$metacolor.query[i],
            label = input$labels,
            cols = colormap[names(x = colormap) %in% unique(x = app.env$object[[input$metacolor.query[i], drop = TRUE]])],
            repel = TRUE,
            reduction = "umap.proj"
          ) + xlim(app.env$plot.ranges[[1]]) +
            ylim(app.env$plot.ranges[[2]])
        }
        wrap_plots(plots, nrow = 1)
      }
    }
  })
  output$evln <- renderPlot(expr = {
    if (!is.null(x = app.env$object)) {
      avail <- c(
        paste0(
          Key(object = app.env$object[["refAssay"]]),
          rownames(x = app.env$object)
        ),
        colnames(x = app.env$object[[]])
      )
      if (nchar(input$scoregroup)) {
        avail <- c(
          avail,
          paste0(
            Key(object = app.env$object[[paste0("prediction.score.", input$scoregroup)]]),
            rownames(x = app.env$object[[paste0("prediction.score.", input$scoregroup)]])
          )
        )
      }
      if (do.adt) {
        avail <- c(
          avail,
          paste0(
            Key(object = app.env$object[[adt.key]]),
            rownames(x = app.env$object[[adt.key]])
          )
        )
      }
      if (app.env$feature %in% avail) {
        if (app.env$feature == "mapping.score" && !resolved(x = app.env$mapping.score)) {
          ggplot() +
            annotate("text", x = 4, y = 25, size=8, label = "Mapping score still computing ... ") +
            theme_void()
        } else {
          title <- ifelse(
            test = grepl(pattern = '^refassay_', x = app.env$feature),
            yes = gsub(pattern = '^refassay_', replacement = '', x = app.env$feature),
            no = app.env$feature
          )
          if (nchar(x = input$scoregroup)) {
            title <- gsub(
              pattern = Key(object = app.env$object[[paste0("prediction.score.", input$scoregroup)]]),
              replacement = 'Prediction Score - ',
              x = app.env$feature
            )
          }
          VlnPlot(
            object = app.env$object,
            features = app.env$feature,
            group.by = input$metagroup,
            pt.size = ifelse(
              test = input$check.featpoints,
              yes = 0,
              no = Seurat:::AutoPointSize(data = app.env$object)
            )
          ) +
            ggtitle(label = title) +
            NoLegend()
        }
      }
    }
  })
  output$edim <- renderPlot(expr = {
    if (!is.null(x = app.env$object)) {
      palettes <- list(
        c("lightgrey", "blue"),
        c('lightgrey', 'darkred')
      )
      names(x = palettes) <- c(
        Key(object = app.env$object[["refAssay"]]),
        'md_'
      )
      if (do.adt) {
        palettes[[Key(object = app.env$object[[adt.key]])]] <-  c('lightgrey', 'darkgreen')
      }
      md <- colnames(x = app.env$object[[]])
      if (nchar(x = input$scoregroup)) {
        md <- c(
          md,
          paste0(
            Key(object = app.env$object[[paste0("prediction.score.", input$scoregroup)]]),
            rownames(x = app.env$object[[paste0("prediction.score.", input$scoregroup)]])
          )
        )
      }
      feature.key <- if (app.env$feature %in% md) {
        'md_'
      } else {
        paste0(
          unlist(x = strsplit(x = app.env$feature, split = '_'))[1],
          '_'
        )
      }
      pal.use <- palettes[[feature.key]]
      if (!is.null(x = pal.use)) {
        if (app.env$feature == "mapping.score" && !resolved(x = app.env$mapping.score)) {
          ggplot() +
            annotate("text", x = 4, y = 25, size=8, label = "Mapping score still computing ... ") +
            theme_void()
        } else {
          title <- ifelse(
            test = grepl(pattern = '^refassay_', x = app.env$feature),
            yes = gsub(pattern = '^refassay_', replacement = '', x = app.env$feature),
            no = app.env$feature
          )
          if (nchar(x = input$scoregroup)) {
            title <- gsub(
              pattern = Key(object = app.env$object[[paste0("prediction.score.", input$scoregroup)]]),
              replacement = 'Prediction Score - ',
              x = app.env$feature
            )
          }
          suppressWarnings(expr = FeaturePlot(
            object = app.env$object,
            features = app.env$feature,
            cols = pal.use,
            reduction = "umap.proj"
          )) + ggtitle(label = title)
        }
      }
    }
  })

  output$mapping.qc.dimplots1 <- renderPlot(expr = {
    p1 <- DimPlot(object = app.env$query.qc, reduction = "qc.orig.umap", label = TRUE) +
      ggtitle("Original UMAP")
    p2 <- DimPlot(object = app.env$query.qc, reduction = "qc.intdr.umap", label = TRUE) +
      ggtitle("Projected UMAP")
    p1 + p2 & NoLegend() & xlab("UMAP 1") & ylab("UMAP 2") & theme(plot.title = element_text(hjust = 0.5))
  })

  output$mapping.qc.dimplots2 <- renderPlot(expr = {
    if (!is.null(x = input$query.qc.meta)) {
      colormaps <- GetColorMap(object = refs$map)[input$query.qc.meta]
      app.env$query.qc[[input$query.qc.meta]] <- app.env$object[[input$query.qc.meta]]
      p1 <- DimPlot(
        object = app.env$query.qc,
        group.by = input$query.qc.meta,
        cols = colormaps[[1]],
        reduction = "qc.orig.umap"
      ) + ggtitle("Original UMAP")
      p2 <- DimPlot(
        object = app.env$query.qc,
        group.by = input$query.qc.meta,
        cols = colormaps[[1]],
        reduction = "qc.intdr.umap"
      ) + ggtitle("Projected UMAP")
      p1 + p2 + plot_layout(guides = 'collect') & xlab("UMAP 1") & ylab("UMAP 2") & theme(plot.title = element_text(hjust = 0.5))
    }
  })

  output$mapping.qc.dimplots <- renderPlot(expr = {
    p1 <- DimPlot(object = app.env$query.qc, reduction = "qc.orig.umap", label = TRUE) +
      ggtitle("Original UMAP")
    p2 <- DimPlot(object = app.env$query.qc, reduction = "qc.intdr.umap", label = TRUE) +
      ggtitle("Projected UMAP")
    p1 + p2 & NoLegend() & xlab("UMAP 1") & ylab("UMAP 2") & theme(plot.title = element_text(hjust = 0.5))
  })

  # Messages
  output$message <- renderUI(expr = {
    p(HTML(text = paste(app.env$messages, collapse = "<br />")))
  })
  output$containerid <- renderUI(expr = {
    p(HTML(text = paste(
      paste("debug ID:", Sys.info()[["nodename"]]),
      paste('Azimuth version:', packageVersion(pkg = 'Azimuth')),
      paste('Seurat version:', packageVersion(pkg = 'Seurat')),
      paste('Reference version:', ReferenceVersion(object = refs$map)),
      sep = "<br />"
    )))
  })
  output$text.cellsremain <- renderText(expr = {
    if (!is.null(x = isolate(app.env$object))) {
      ncount <- paste0('nCount_', DefaultAssay(object = isolate(app.env$object)))
      nfeature <- paste0('nFeature_', DefaultAssay(object = isolate(app.env$object)))
      cells.use <- isolate(app.env$object)[[ncount, drop = TRUE]] >= input$num.ncountmin &
        isolate(app.env$object)[[ncount, drop = TRUE]] <= input$num.ncountmax &
        isolate(app.env$object)[[nfeature, drop = TRUE]] >= input$num.nfeaturemin &
        isolate(app.env$object)[[nfeature, drop = TRUE]] <= input$num.nfeaturemax
      if (any(grepl(pattern = mito.pattern, x = rownames(x = isolate(app.env$object))))) {
        cells.use <- cells.use &
          isolate(app.env$object)[[mt.key, drop = TRUE]] >= input$minmt &
          isolate(app.env$object)[[mt.key, drop = TRUE]] <= input$maxmt
      }
      paste(sum(cells.use), "cells remain after current filters")
    }
  })
  output$text.dladt <- renderText(
    expr = {
      c(
        "imputed.assay <- readRDS('azimuth_impADT.Rds')",
        "object <- object[, Cells(imputed.assay)]",
        "object[['impADT']] <- imputed.assay"
      )
    },
    sep = "\n"
  )
  output$text.dlumap <- renderText(
    expr = {
      c(
        "projected.umap <- readRDS('azimuth_umap.Rds')",
        "object <- object[, Cells(projected.umap)]",
        "object[['umap.proj']] <- projected.umap"
      )
    },
    sep = "\n"
  )
  output$text.dlpred <- renderText(
    expr = {
      c(
        "predictions <- read.delim('azimuth_pred.tsv', row.names = 1)",
        "object <- AddMetaData(",
        "\tobject = object,",
        "\tmetadata = predictions)"
      )
    },
    sep = "\n"
  )
  # Tables
  output$table.qc <- renderTable(
    expr = {
      if (!is.null(x = isolate(app.env$object))) {
        qc <- paste0(c('nCount_', 'nFeature_'), app.env$default.assay)
        tbl <- apply(X = isolate(app.env$object)[[qc]], MARGIN = 2, FUN = quantile)
        tbl <- as.data.frame(x = tbl)
        colnames(x = tbl) <- c('nUMI per cell', 'Genes detected per cell')
        if (mt.key %in% colnames(x = isolate(app.env$object)[[]])) {
          tbl[, 3] <- quantile(x = isolate(app.env$object)[[mt.key, drop = TRUE]])
          colnames(x = tbl)[3] <- 'Mitochondrial percentage per cell'
        }
        t(x = tbl)
      }
    },
    rownames = TRUE
  )
  output$biomarkers <- renderDT(
    expr = {
      if (!is.null(x = app.env$diff.expr[[paste(app.env$default.assay, input$markerclustersgroup, sep ="_")]])) {
        RenderDiffExp(
          diff.exp =  app.env$diff.expr[[paste(app.env$default.assay, input$markerclustersgroup, sep ="_")]],
          groups.use = input$markerclusters,
          n = Inf
        )
      }
    },
    selection = 'single',
    options = list(dom = 't')
  )
  output$adtbio <- renderDT(
    expr = {
      if (!is.null(x = app.env$diff.expr[[paste(adt.key, input$markerclustersgroup, sep = "_")]])) {
        RenderDiffExp(
          diff.exp = app.env$diff.expr[[paste(adt.key, input$markerclustersgroup, sep = "_")]],
          groups.use = input$markerclusters,
          n = Inf
        )
      }
    },
    selection = 'single',
    options = list(dom = 't')
  )
  output$table.metadata <- renderTable(
    expr = {
      if (!is.null(x = app.env$object)) {
        CategoryTable(
          object = app.env$object,
          category.1 = input$metarow,
          category.2 = input$metacol,
          percentage = (input$radio.pct == "Percentage")
        )
      }
    },
    rownames = TRUE
  )
  # Downloads
  output$dlumap <- downloadHandler(
    filename = paste0(tolower(x = app.title), '_umap.Rds'),
    content = function(file) {
      if (!is.null(x = app.env$object)) {
        if ('umap.proj' %in% Reductions(object = app.env$object)) {
          saveRDS(object = app.env$object[['umap.proj']], file = file)
        }
      }
    }
  )
  output$dladt <- downloadHandler(
    filename = paste0(tolower(x = app.title), '_impADT.Rds'),
    content = function(file) {
      if (!is.null(x = app.env$object)) {
        if ('impADT' %in% Assays(object = app.env$object)) {
          saveRDS(object = app.env$object[['impADT']], file = file)
        }
      }
    }
  )
  output$dlpred <- downloadHandler(
    filename = paste0(tolower(x = app.title), '_pred.tsv'),
    content = function(file) {
      req <- paste0("predicted.", c(app.env$metadataxfer, paste0(app.env$metadataxfer, ".score")))
      if (resolved(x = app.env$mapping.score)) {
        req <- c(req, 'mapping.score')
      }
      if (all(req %in% colnames(x = app.env$object[[]]))) {
        pred.df <- app.env$object[[req]]
        if (resolved(x = app.env$mapping.score)) {
          pred.df$mapping.score <- value(app.env$mapping.score)
        }
        pred.df <- cbind(cell = rownames(x = pred.df), pred.df)
        write.table(
          x = pred.df,
          file = file,
          quote = FALSE,
          row.names = FALSE,
          col.names = TRUE,
          sep = '\t'
        )
      }
    }
  )
  output$dlscript <- downloadHandler(
    filename = paste0(tolower(x = app.title), '_analysis.R'),
    content = function(file) {
      template <- readLines(con = system.file(
        file.path('resources', 'template.R'),
        package = 'Azimuth'
      ))
      template <- paste(template, collapse = '\n')
      e <- new.env()
      e$ref.uri <- 'https://seurat.nygenome.org/references/pbmc/'
      e$path <- input$file$name
      e$mito.pattern <- getOption(x = 'Azimuth.app.mito', default = '^MT-')
      e$mito.key <- mt.key
      e$ncount.max <- input$num.ncountmax
      e$ncount.min <- input$num.ncountmin
      e$nfeature.max <- input$num.nfeaturemax
      e$nfeature.min <- input$num.nfeaturemin
      e$mito.max <- input$maxmt
      e$mito.min <- input$minmt
      e$sct.ncells <- getOption(x = 'Azimuth.sct.ncells')
      e$sct.nfeats <- getOption(x = 'Azimuth.sct.nfeats')
      e$ntrees <- getOption(x = 'Azimuth.map.ntrees')
      e$adt.key <- adt.key
      e$do.adt <- do.adt
      e$metadataxfer <- app.env$metadataxfer
      if (length(x = e$metadataxfer == 1)) {
        e$metadataxfer <- paste0("\"", e$metadataxfer, "\"")
      }
      e$plotgene <- getOption(x = 'Azimuth.app.default_gene')
      e$plotadt <- getOption(x = 'Azimuth.app.default_adt')
      writeLines(text = str_interp(string = template, env = e), con = file)
    }
  )
  # render UI elements that depend on arguments
  output$welcomebox <- renderUI(
    expr = eval(expr = parse(text = getOption(x = "Azimuth.app.welcomebox")))
  )
}
